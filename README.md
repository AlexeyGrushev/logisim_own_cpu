# logisim_own_cpu
Processor circuit Own CPU v1.0
# Own CPU v1.0

Представляет собой проет учебного процессора на собственной архитектуре. Разрабатывется по подобию учебного процессора программы Lampanel



Схема также имеет графические рисунки по [Own CPU v1.0](file:///workspace/2bddda79-dbe8-49dd-8d89-ed637495c3cf/DJIYgNEsjr?mode=edgeless) (наброски)



## Регистры

### Регистры общего назначения

![](assets/Emhc70bumU1XVbi-lEkgiJv-vIxvK-XBeR19UNzWJsg=.png)

Регистры общего назначения предназначены **для хранения операндов арифметико-логических инструкций, а также адресов или отдельных компонентов адресов ячеек памяти**. Можно записывать и считывать данные с любого из 4 регистров



### Служебные регистры

![](assets/O8vy6q3J6m3tNiUZ2cD_3QmdRJ3VSKQ6woz4sYsJMYE=.png)

У процессора есть 5 служебных регистров, в которых храниться информация во время выполнения инструкций:

\<u>OPCODE\</u> - сохраняет код команды, которую будет выполнять процессор

\<u>OPTYPE/SREG\</u> - сохраняет значение откуда нужно будет получить информацию:

* Если там оказывается значение D(13) - значит данные находятся в следующей ячейке оперативной памяти
* Если значение A(10) - значит, что в следующей ячейке ОЗУ находится 2-байтовый адрес, по которому необходимо получить данные
* Если значение от 0-3(HEX) - значит данные для обработки находятся в одном из 4 регистров общего назначения

\<u>DREG\</u> - сохраняет регистр конечного назначения. Определяет куда именно будет записан результат

\<u>DATA\</u> - Хранит данные для обработки

\<u>ADR\</u> - хранит адрес откуда именно были получены данные

![](assets/SHBXbIF8S1AllUS5CQICmv99L10xYSqNmHt45uFSo80=.png)

\<u>PS\</u> (Program counter) - является счётчиком комманд, через него процессор перемещается по оперативной памяти.

У него есть следующие режимы работы:

00 - Обычный режим работы, к текущему значению прибавляется 1

01 - Режим двойного инкремента. Как первый, но к текущему значению прибавляется 2

10 - Режим загрузки значения в счётчик. Подается на вход LD 16-bit

11 - Режим Halt. Счётчик никак не изменяет своего значения при подаче тактового сигнала



## Как процессор выполняет вычисления❓

**Процессор имеет 4 стадии выполнения инструкций:**

\<u>FETCH\</u> - получение инструкции по адресу, который установлен на счётчике комманд

\<u>DECODE\</u> - декодирование инструкции и загрузка правильных данных в служебые регистры

\<u>EXECUTE\</u> - выполнение арифметических действий над данными

\<u>WRITE\</u> - запись информации в место назначения

![](assets/2UYFJprBEx5S9psnZBqONAYFBGb75ElfHNjuV24sorM=.png)

За переключение состояний отвечает **фазовый детерменированный конечный автомат**, который определяет в каком из состояний находится процессор и где именно в данный момент должны выполняться такты синхронизации. Также фазовый автомат определяет какой именно стадии на данный момент требуется передать управление режимом **счётчика команд (PC)** и **A&#x20;**&#x432;ходу на RAM.

![](assets/0g6jiJ5Tmsv_bPdfSH-8LiAfP6KN87yPOKOyD_iAEoU=.png)

> \<u>Внутреннее устройство фазового ДКА\</u>.

## Подробное описание каждой стадии

### FETCH

![](assets/JvWE60us0AGy1PLC5k4TS98K4-CEpuNvSwMggTzPnCA=.png)

> \<u>One action FETCH FSM\</u>

Фаза считывания (fetch) отвечает за получение инструкции, которая в данный момент находится по адресу, указанному счётчиком команд (PC). За один такт процессор обращается к оперативной памяти, считывает машинную команду и декодирует её на составные части. Полученная информация распределяется по специализированным регистрам: код операции (OPCODE) загружается в одноимённый регистр, тип операции или исходный регистр (OPTYPE/SREG) — в соответствующий регистр, а регистр назначения (DREG) — в свой регистр. Эти данные подготавливаются для последующих фаз работы процессора, таких как декодирование, выполнение и запись результата.

### DECODE

![](assets/LQHwWvmTf7uzeyDBJc0IBmi35e0gUNfpjh-3DpoDxsE=.png)

> \<u>Декодер команд процессора\</u>

![](assets/NGQvs0HYGgN6fUitbWZmlE4VZUJw8pK8V9N0oMbw3bQ=.png)

> \<u>Схема конечного автомата декодера\</u>

Во время декодирования команды, которая записалась в служебные регистры во время выполнения предыдущей стадии, процессор дополучает необходимые ему данные. Для начала определяется откуда нужно собрать данные для обработки.

* xx**0-3**x — обозначает, что данные нужно получить из регистров общего назначения. На выполнение тратится 1 слот ОЗУ
* xx**D**x — означает, что в следующей ячейке находятся данные, с которыми как-то надо будет взаимодействовать. Декодер получает данные, а выполнение занимает 2  слота в ОЗУ
* xx**A**x — означает, что в следующей ячейке находится адрес, с которого декодеру нужно извлечь данные для дальнейшего взаимодействия с ними. Также занимает 2 слота в ОЗУ. Требует больше всего затрат на выполнение, потому что перемещает счётчик команд наибольшее количество раз для извлечения данных

### EXECUTE

![](assets/O0A1nlpNaPjBVWzj4JVJZ3qYmHD4GY_kjgEFtUUgdyE=.png)

> \<u>Блок выполнения арифметических вычислений процессора\</u>

После того как все данные получены, декодированы и записаны в служебные регистры процессор переходит к **фазе выполнения инструкции**(execute). На этом этапе:

* Управляющий автомат активирует соответствующий блок.
* Исходя из типа команды, происходит **арифметическая/логическая операция**— ALU берёт операнды из регистров (например,`R1`,`R2`), выполняет нужное действие (сложение, вычитание, логическое "И", "ИЛИ", сдвиг и др.) и переходит к следующей стадии.

### WRITE

![](assets/WtoESTpyK5RGACOrgUI4feB4KSi9yrhzewPWfyi24SQ=.png)

WRITE — завершение команды и изменение потока управления

На фазе происходит окончательная фиксация результатов выполнения инструкции. В зависимости от типа команды, процессор:

* Записывает результат операции ALU в целевой регистр или память;
* Обновляет специальные регистры (например, регистр состояния`PS`);
* Обрабатывает команды переходов (`jmp`,`jz`,`jn`, и др.):
  * Если заданное условие перехода выполнено (например, флаг нуля установлен после предыдущей операции), счётчик команд (`PC`) перенаправляется на указанный адрес;
  * Иначе —`PC` просто увеличивается на 1, и выполнение продолжается последовательно.

## Команды, выполняемые процессором

| Команда | OPCODE | Значение                                                                                                                                                |
| ------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| mov     | 01RR   | Из регистра в регистр&#xA;R - Номер регистра&#xA;1 - Откуда&#xA;2 - Куда                                                                                |
| mov     | 01DR   | Из памяти в регистр&#xA;D - Обозначает следующую ячейку в памяти&#xA;R - Регистр                                                                        |
| mov     | 01AR   | Из памяти в регистр&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;R - Регистр                                                          |
| add     | 02RR   | Сложить два регистра&#xA;R - Номер регистра                                                                                                             |
| add     | 02DR   | Сложить значение из памяти из регистра&#xA;D - Обозначает следующую ячейку в памяти&#xA;R - Регистр                                                     |
| add     | 02AR   | Сложить значение по адресу&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;R - Регистр                                                   |
| sub     | 03RR   | Вычесть два регистра&#xA;R - Номер регистра                                                                                                             |
| sub     | 03DR   | Вычесть значение из памяти из регистра&#xA;D - Обозначает следующую ячейку в памяти&#xA;R - Регистр                                                     |
| sub     | 03AR   | Вычесть значение из памяти из регистра&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;R - Регистр                                       |
| cmp     | 04RR   | Сравнить значения в регистрах &#xA;R - Регистр                                                                                                          |
| cmp     | 04DR   | Сравнить следующую ячейку в памяти со значением в регистре&#xA;D - Обозначает следующую ячейку в памяти&#xA;R - Регистр                                 |
| cmp     | 04AR   | Сравнить значение по адресу со значением в регистре&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;R - Регистр                          |
| stop    | FFFF   | Останавливает работу процессора до сброса                                                                                                               |
| not     | 05RR   | Инвертировать данные в регистре.&#xA;R - Регистр&#xA;1 - в каком регистре нужно поменять число&#xA;2 - в какой нужно его записать                       |
| and     | 06RR   | Логическое И с двумя регистрами&#xA;R - регистр                                                                                                         |
|         |        |                                                                                                                                                         |
| and     | 06DR   | Логическое И с данными из следующей ячейки и регистром&#xA;D - Обозначает следующую ячейку в памяти&#xA;R - Регистр                                     |
| and     | 06AR   | Логическое И с данными по адресу в следующей ячейке&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;R - Регистр                          |
| or      | 07RR   | Логическое ИЛИ с двумя регистрами&#xA;R - регистр                                                                                                       |
| or      | 07DR   | Логическое ИЛИ с данными из следующей ячейки и регистром&#xA;D - Обозначает следующую ячейку в памяти&#xA;R - Регистр                                   |
| or      | 07AR   | Логическое ИЛИ с данными по адресу в следующей ячейке&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;R - Регистр                        |
| shl     | 08RR   | Логический сдвиг влево&#xA;R - регистр&#xA;1 - в каком регистре взять данные&#xA;2 - куда записать                                                      |
| sar     | 09RR   | Арифметический сдвиг вправо&#xA;R - регистр&#xA;1 - в каком регистре взять данные&#xA;2 - куда записать                                                 |
| in      | 0aRP   | Загрузка значения с регистра в один из портов&#xA;R - регистр&#xA;P - порт                                                                              |
| out     | 0bPR   | Загрузка значения из порта в регистр&#xA;P - порт&#xA;R - регистр                                                                                       |
| jmp     | 0cDX   | Безусловный переход по адресу в следующей ячейке&#xA;D - Обозначает следующую ячейку в памяти&#xA;X - не имеет значения                                 |
| jmp     | 0cAX   | Безусловный переход по адресу, который хранится в следующей ячейке&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;X - не имеет значения |
| jnz     | 0dDX   | Переход если Zero Flag выключен&#xA;D - Обозначает следующую ячейку в памяти&#xA;X - не имеет значения                                                  |
| jnz     | 0dAX   | Переход если Zero Flag выключен&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;X - не имеет значения                                    |
| jz      | 0eDX   | Переход если Zero Flag включен&#xA;D - Обозначает следующую ячейку в памяти&#xA;X - не имеет значения                                                   |
| jz      | 0eAX   | Переход если Zero Flag включен&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;X - не имеет значения                                     |
| jg      | 0fDX   | Переход если больше&#xA;D - Обозначает следующую ячейку в памяти&#xA;X - не имеет значения                                                              |
| jg      | 0fAX   | Переход если больше&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;X - не имеет значения                                                |
| jge     | 10DX   | Переход если больше или равно&#xA;D - Обозначает следующую ячейку в памяти&#xA;X - не имеет значения                                                    |
| jge     | 10AX   | Переход если больше или равно&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;X - не имеет значения                                      |
| jl      | 11DX   | Переход если меньше&#xA;D - Обозначает следующую ячейку в памяти&#xA;X - не имеет значения                                                              |
| jl      | 11AX   | Переход если меньше&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;X - не имеет значения                                                |
| jle     | 12DX   | Переход если меньше или равно&#xA;D - Обозначает следующую ячейку в памяти&#xA;X - не имеет значения                                                    |
| jle     | 12AX   | Переход если меньше или равно&#xA;A - Обозначает, что в следующей ячейке находится адрес&#xA;X - не имеет значения                                      |
| data    | 13RX   | Записать значение с регистра в следующую ячейку                                                                                                         |

## HEX-коды команд

| Команда | ASCII код   |
| ------- | ----------- |
| mov     | 6d 6f 76    |
| add     | 61 64 64    |
| sub     | 73 75 62    |
| cmp     | 63 6d 70    |
| not     | 6e 6f 74    |
| and     | 61 6e 64    |
| or      | 6f 72       |
| shl     | 73 68 6c    |
| sar     | 73 61 72    |
| in      | 69 6e       |
| out     | 6f 75 74    |
| jmp     | 6a 6d 70    |
| jnz     | 6a 6e 7a    |
| jz      | 6a 7a       |
| jg      | 6a 67       |
| jge     | 6a 67 65    |
| jl      | 6a 6c       |
| jle     | 6a 6c 65    |
| data    | 64 61 74 61 |

## Ассемблер процессора

![](assets/_xD4IFMnI9GDvsmXrRaXeSBgcD8T9ph23I6Agn3cy3g=.png)

> \<u>Cхема ассемблера\</u>

\<u>Д\</u>елимитером для ввода команды является /, а для выхода \[SPACE]

Без / будут записываться данные

Пример программы

```asm
/mov d0[enter]
0101[enter]
/mov 01[enter]
/add 01[enter]
```

